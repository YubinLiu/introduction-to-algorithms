## 通过一个简单的例子进行动态规划的学习，以及讲解其使用
参考自: http://lib.csdn.net/article/datastructure/9390
### 例: 数字三角形

#### 一、问题描述：
```
    7
   3 8
  8 1 0
 2 7 4 4
4 5 2 6 5

在如上的数字三角形中，寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。

路径上的每一步都只能往 左下 或 右下。只需要求出这个最大和即可，不必给出具体路径。

三角形的行数大于1小于等于100，数字为 0 - 99。
```

#### 二、输入输出:
```
输入格式：
   5                //表示三角形的行数，接下来输入三角形
   7
   3   8
   8   1   0
   2   7   4   4
   4   5   2   6   5

输出： 最大和
```

#### 三、 分析：
##### 第一次尝试：
* 二维数组存放数字三角形；
* triangle[i][j] 表示第 i 行， 第 j 个数字（i， j 从 1 开始计算）， maxSum(i, j)表示从 triangle[i][j] 到底边各条路径中，最佳路径的数字和（即和最大）；
* 最终问题即为求 maxSum(1, 1)。
* 从 triangle[i][j] 出发，下一步只能到 triangle[i + 1][j]，或 triangle[i + 1][j + 1]。
* 对于 n 行的三角形，写出递归式如下：
```
if (i == n) return maxSum(i, j);
else
    maxSum(i, j) = max( maxSum(i + 1, j), maxSum(i + 1, j + 1) ) + triangle[i][j];
```

根据递归式，写出的解决方案见 [code/FirstTest.java](https://github.com/YubinLiu/introduction-to-algorithms/blob/master/15_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BE%8B%E5%AD%90/code/FirstTest.java)。

##### 第二次尝试：
第一次尝试中存在着大量的重复计算，将计算出的三角形每个点的最佳路径的数字和保存起来，之后便可直接获取而不用再计算一遍。称为“ 带备忘的自顶向下法 ”。

写出的解决方案见 [code/SecondTest.java](https://github.com/YubinLiu/introduction-to-algorithms/blob/master/15_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BE%8B%E5%AD%90/code/SecondTest.java)。

##### 第三次尝试：
改变递归为递推。递归需要用到大量堆栈上的空间，易造成栈溢出，所以可将其改为“ 自底向上法 ”。
对于上述数字三角形，分析如下：
```
第一步：首先计算最后一行，可将其直接写出。
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               4 5 2 6 5

第二步：对于倒数第二行的 2，可以与下一行的 4 或 5 相加，与 5 相加得到的数更大，就将 （2 + 5）保存起来；对于后面的 7，4，4，分析同理。
7
3 8
8 1 0
2 7 4 4                7  12 10 10
4 5 2 6 5              4  5  2  6  5

第三步：对于剩下几行的数做相同的操作，如下：
7                      
3 8                    
8 1 0                  20 13 10
2 7 4 4                7  12 10 10
4 5 2 6 5              4  5  2  6  5

7                      
3 8                    23 21
8 1 0                  20 13 10
2 7 4 4                7  12 10 10
4 5 2 6 5              4  5  2  6  5

7                      30
3 8                    23 21
8 1 0                  20 13 10
2 7 4 4                7  12 10 10
4 5 2 6 5              4  5  2  6  5
```
根据上述过程，写出递推型，“ 自底向上法 ”的解决方案，见 [code/ThirdTest.java](https://github.com/YubinLiu/introduction-to-algorithms/blob/master/15_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BE%8B%E5%AD%90/code/ThirdTest.java)。

##### 第四次尝试：
无需用二维数组存储三角形每一个点的最佳路径的数字和的值，只需用一维数组即可，该尝试仅对于空间优化。具体步骤如下：
```
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               4 5 2 6 5

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               7 5 2 6 5

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               7 12 2 6 5

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               7 12 10 6 5

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               7 12 10 10 5

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               20 12 10 10 5

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               20 13 10 10 5

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               20 13 10 10 5

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               23 21 10 10 5

7
3 8
8 1 0
2 7 4 4
4 5 2 6 5               30 21 10 10 5
```

根据上述步骤写出的解决方案见 [code/FourthTest.java](https://github.com/YubinLiu/introduction-to-algorithms/blob/master/15_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BE%8B%E5%AD%90/code/FourthTest.java)。
